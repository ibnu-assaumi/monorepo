// Code generated by candi v1.8.8.

package repository

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"monorepo/services/seaotter/internal/modules/salesorder/domain"
	shareddomain "monorepo/services/seaotter/pkg/shared/domain"

	"github.com/Bhinneka/candi/tracer"

	"github.com/Bhinneka/candi/candihelper"
)

type salesorderRepoMongo struct {
	readDB, writeDB *mongo.Database
	collection      string
}

// NewSalesorderRepoMongo mongo repo constructor
func NewSalesorderRepoMongo(readDB, writeDB *mongo.Database) SalesorderRepository {
	return &salesorderRepoMongo{
		readDB:     readDB,
		writeDB:    writeDB,
		collection: shareddomain.Salesorder{}.CollectionName(),
	}
}

func (r *salesorderRepoMongo) FetchAll(ctx context.Context, filter *domain.FilterSalesorder) (data []shareddomain.Salesorder, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "SalesorderRepoMongo:FetchAll")
	defer func() { trace.SetError(err); trace.Finish() }()

	where := bson.M{}
	trace.SetTag("query", where)

	findOptions := options.Find()
	if len(filter.OrderBy) > 0 {
		findOptions.SetSort(filter)
	}

	if !filter.ShowAll {
		findOptions.SetLimit(int64(filter.Limit))
		findOptions.SetSkip(int64(filter.Offset))
	}
	cur, err := r.readDB.Collection(r.collection).Find(ctx, where, findOptions)
	if err != nil {
		return nil, err
	}
	defer cur.Close(ctx)

	cur.All(ctx, &data)
	return
}

func (r *salesorderRepoMongo) Find(ctx context.Context, filter *domain.FilterSalesorder) (result shareddomain.Salesorder, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "SalesorderRepoMongo:Find")
	defer func() { trace.SetError(err); trace.Finish() }()

	bsonWhere := make(bson.M)
	if filter.ID != "" {
		bsonWhere["_id"], _ = primitive.ObjectIDFromHex(filter.ID)
	}
	trace.SetTag("query", bsonWhere)

	err = r.readDB.Collection(r.collection).FindOne(ctx, bsonWhere).Decode(&result)
	return
}

func (r *salesorderRepoMongo) Count(ctx context.Context, filter *domain.FilterSalesorder) int {
	trace, ctx := tracer.StartTraceWithContext(ctx, "SalesorderRepoMongo:Count")
	defer trace.Finish()

	where := bson.M{}
	count, err := r.readDB.Collection(r.collection).CountDocuments(trace.Context(), where)
	trace.SetError(err)
	return int(count)
}

func (r *salesorderRepoMongo) Save(ctx context.Context, data *shareddomain.Salesorder) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "SalesorderRepoMongo:Save")
	defer func() { trace.SetError(err); trace.Finish() }()
	tracer.Log(ctx, "data", data)

	data.ModifiedAt = time.Now()
	if data.ID == "" {
		data.ID = primitive.NewObjectID().Hex()
		data.CreatedAt = time.Now()
		_, err = r.writeDB.Collection(r.collection).InsertOne(ctx, data)
	} else {
		opt := options.UpdateOptions{
			Upsert: candihelper.ToBoolPtr(true),
		}
		_, err = r.writeDB.Collection(r.collection).UpdateOne(ctx,
			bson.M{
				"_id": data.ID,
			},
			bson.M{
				"$set": data,
			}, &opt)
	}

	return
}

func (r *salesorderRepoMongo) Delete(ctx context.Context, id string) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "SalesorderRepoMongo:Delete")
	defer func() { trace.SetError(err); trace.Finish() }()

	objectID := id
	_, err = r.writeDB.Collection(r.collection).DeleteOne(ctx, bson.M{"_id": objectID})
	return
}
